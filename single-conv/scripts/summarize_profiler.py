#!/usr/bin/env python3

import argparse
import itertools
import sys
from pathlib import Path
from collections import defaultdict

import matplotlib.pyplot as plt
from matplotlib import rc
import numpy as np
import pandas as pd
from filter_csv import exclude_from_df, include_only_in_df, split_parameters, get_categories
from tabulate import tabulate
import scipy.stats as st
from matplotlib.ticker import FuncFormatter


def perf_log_to_df(input_log : Path, incorrect_convs : pd.DataFrame = None, new_method : str = None, old_method : str = None, relative : bool = False):

    data = defaultdict(list)
    counters = set()
    with open(input_log, 'r') as f:
        perf_stat_seen = 0
        for line in f:
            if line.strip() == '' or "started on" in line:
                continue

            if "/process_time/real_time" in line:
                id = line.split(',')[0].replace('"', '').split('/')[0]
                conv_type = id.split(' ')[0]
                conv_parameters = " ".join(id.split(' ')[1:])
                data['conv_parameters'].append(conv_parameters)
                data['conv_type'].append(conv_type)
                data['error_occurred'].append(line.split(',')[8])
            else:
                counter = line.split(',')[2]
                if '/' in counter:
                    counter = counter.split("/")[1]
                counters.add(counter)
                count = line.split(',')[0]
                if count == "<not counted>" or count == "<not supported>":
                    count = np.nan
                data[counter].append(count)

    df = pd.DataFrame(data)

    # Remove rows where error_occurred is True (happens when Yaconv is not supported)
    df = df.loc[df["error_occurred"] != "true"]
    # Remove row where results were incorrect
    if incorrect_convs is not None:
        df = df.merge(incorrect_convs, how="left", on=["conv_type", "conv_parameters"], indicator=True)
        df = df.loc[df["_merge"] == "left_only"]
        df = df.drop(columns=["_merge", "max_diff", "tolerance"])

    # Separate df by 'conv_type'
    groups = df.groupby(by=["conv_type"])
    df_dict = {}
    for name, group in groups:
        name = name[0]
        df_dict[name] = group.reset_index(drop=True)

    # Join results by 'conv_parameters'
    method_names = list(df_dict.keys())
    if old_method is not None and old_method not in method_names:
        print(f"Method {old_method} not found in results.", file=sys.stderr)
        print(f"Available methods: {method_names}", file=sys.stderr)
        sys.exit(-1)
    if new_method is not None and new_method not in method_names:
        print(f"Method {new_method} not found in results.", file=sys.stderr)
        print(f"Available methods: {method_names}", file=sys.stderr)
        sys.exit(-1)

    if len(method_names) == 1:
        print("Only one method found. No comparison possible.", file=sys.stderr)
        sys.exit(-1)

    for counter in sorted(counters):
        joined_results = pd.merge(
            df_dict[method_names[0]][["conv_parameters", counter]].rename(columns={counter: method_names[0]}),
            df_dict[method_names[1]][["conv_parameters", counter]].rename(columns={counter: method_names[1]}),
            how="left",
            on="conv_parameters",
            suffixes=(None, None),
        )
        for method_name in method_names[2:]:
            joined_results = joined_results.merge(
                df_dict[method_name][["conv_parameters", counter]].rename(columns={counter: method_name}),
                how="left",
                on="conv_parameters",
                suffixes=(None, None),
            )

        if new_method is not None:
            if relative:
                for method_name in method_names:
                    if method_name == new_method:
                        continue
                    else:
                        joined_results[method_name] = joined_results[method_name].astype("Int64") / joined_results[new_method].astype("Int64")
                joined_results[new_method] = 1

            if old_method is not None:
                cols = ["conv_parameters", old_method, new_method]
                joined_results = joined_results[cols].dropna()

        joined_results = joined_results.rename(columns={"conv_parameters": counter}).set_index(counter)
        print(tabulate(joined_results, headers="keys", tablefmt="psql", floatfmt=".1f"))


if __name__ == "__main__":

    parser = argparse.ArgumentParser(
        description="Parse output log with profiler results and summarize them into a table."
    )

    parser.add_argument(
        "Log_Input", type=str, help="Path to the input log file (generated by benchmark_runner with --save-profile)."
    )
    parser.add_argument(
        "--incorrect-convs",
        type=str,
        help="Path to csv that contains convolution that generated incorrect results. Excludes these convolutions from the graphs if the method that generated them is part of the comparison.",
    )
    parser.add_argument(
        "--new-method",
        type=str,
        help="Name of the new method to be compared.",
    )
    parser.add_argument(
        "--old-method",
        type=str,
        help="Name of the old method to be compared. If not provided, all methods are shown.",
    )
    parser.add_argument(
        "--relative",
        action="store_true",
        help="If enabled, results are relative to the new method, otherwise absolute values are shown.",
    )

    args = parser.parse_args()
    incorrect_convs = args.incorrect_convs
    old_method = args.old_method
    new_method = args.new_method
    relative = args.relative

    input_log = Path(args.Log_Input)

    # Check if csv file exists
    if (not input_log.exists()) or (not input_log.is_file()):
        print("CSV with results not found.", file=sys.stderr)
        sys.exit(-1)

    if new_method is None and old_method is not None:
        print("Only providing old_method is not supported.", file=sys.stderr)
        sys.exit(-1)

    incorrect_conv_df = None
    if incorrect_convs:
        incorrect_convs = Path(incorrect_convs)
        if (not incorrect_convs.exists()) or (not incorrect_convs.is_file()):
            print("CSV with incorrect convolutions not found.", file=sys.stderr)
            sys.exit(-1)
        incorrect_conv_df = pd.read_csv(incorrect_convs, header=0, index_col=False)

    df = perf_log_to_df(input_log, incorrect_conv_df, new_method, old_method, relative)

